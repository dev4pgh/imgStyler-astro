This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
public/
  robots.txt
  site.webmanifest
src/
  components/
    canvas/
      ImageCanvas.jsx
    controls/
      ExportControls.jsx
    sidebar/
      AdjustmentsPanel.jsx
      CropPanel.jsx
      FiltersPanel.jsx
      Sidebar.jsx
    ui/
      FileUpload.jsx
      Header.jsx
      ThemeToggleButton.jsx
    InteractiveImage.jsx
  constants/
    adjustments.js
    cropPresets.js
    exportOptions.js
    filters.js
  context/
    EditingContext.js
  hooks/
    useCanvasDisplaySize.js
    useCroppingState.js
    useExportManager.js
    useImageLoader.js
    useInteractiveCrop.js
  layouts/
    Layout.astro
  lib/
    EffectEngine.js
    exportUtils.js
  pages/
    about.astro
    contact.astro
    features.astro
    index.astro
  styles/
    global.css
.env.example
.gitignore
astro.config.mjs
LICENSE
package.json
README.md
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="public/robots.txt">
User-agent: *
Allow: /

Sitemap: https://imgstyler.app/sitemap-index.xml
</file>

<file path="public/site.webmanifest">
{"name":"","short_name":"","icons":[{"src":"/android-chrome-192x192.png","sizes":"192x192","type":"image/png"},{"src":"/android-chrome-512x512.png","sizes":"512x512","type":"image/png"}],"theme_color":"#ffffff","background_color":"#ffffff","display":"standalone"}
</file>

<file path="src/components/canvas/ImageCanvas.jsx">
import React, { useEffect, useRef, useState, useCallback, useImperativeHandle, forwardRef } from "react";
import { applyAllEffects } from "../../lib/EffectEngine";
import { useInteractiveCrop } from "../../hooks/useInteractiveCrop";
import { useCanvasDisplaySize } from "../../hooks/useCanvasDisplaySize";

const ImageCanvas = forwardRef(({
    imageObject, crop, filter, adjustments, format, quality, lossless,
    isCropping, aspectRatio, cropRounding, lockAspectRatio,
}, ref) => {
    const containerRef = useRef(null);
    const canvasRef = useRef(null);
    const overlayRef = useRef(null);
    const previewImageRef = useRef(new Image());
    const { width: canvasWidth, height: canvasHeight, scale: currentScale } = useCanvasDisplaySize(containerRef, crop, imageObject);

    const {
        interactiveCrop: currentInteractiveCropFromHook,
        overlayProps,
        handleProps,
        isInteracting,
    } = useInteractiveCrop({
        containerRef,
        canvasWidth: canvasWidth,
        canvasHeight: canvasHeight,
        aspectRatio,
        lockAspectRatio,
        isCropping,
        cropRounding,
        disabled: !isCropping,
    });

    useEffect(() => {
        const canvas = canvasRef.current;
        let isImageReady = false;
        if (imageObject instanceof HTMLImageElement) {
            isImageReady = imageObject.complete && imageObject.naturalWidth > 0;
        } else if (imageObject instanceof HTMLCanvasElement) {
            isImageReady = imageObject.width > 0 && imageObject.height > 0;
        }
        if (!imageObject || !isImageReady || !crop || !canvas || canvasWidth <= 0 || canvasHeight <= 0) {
            const canvas = canvasRef.current;
            if (canvas) {
                const ctx = canvas.getContext("2d");
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                if (canvas.width !== 0) canvas.width = 0;
                if (canvas.height !== 0) canvas.height = 0;
            }
            return;
        }

        const ctx = canvas.getContext("2d");
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;

        const tmpCanvas = document.createElement("canvas");
        tmpCanvas.width = canvasWidth;
        tmpCanvas.height = canvasHeight;
        const tmpCtx = tmpCanvas.getContext("2d");
        const roundingForDisplay = isCropping ? 0 : cropRounding;
        applyAllEffects(tmpCtx, imageObject, tmpCanvas, filter, adjustments, crop, roundingForDisplay);

        const requiresPreview = format === "image/jpeg" || (format === "image/webp" && !lossless);
        if (requiresPreview) {
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            ctx.drawImage(tmpCanvas, 0, 0, canvasWidth, canvasHeight);

            const blobOptions = { quality: quality / 100 };
            tmpCanvas.toBlob((blob) => {
                if (!blob) { /* ... error handling ... */ return; }
                const compressedUrl = URL.createObjectURL(blob);
                const previewImg = previewImageRef.current;
                previewImg.onload = () => {
                    ctx.drawImage(previewImg, 0, 0, canvasWidth, canvasHeight);
                    URL.revokeObjectURL(compressedUrl);
                };
                previewImg.onerror = () => { /* ... error handling ... */ ctx.drawImage(tmpCanvas, 0, 0, canvasWidth, canvasHeight); URL.revokeObjectURL(compressedUrl); }
                previewImg.src = compressedUrl;
            }, format, blobOptions.quality);
        } else {
            ctx.drawImage(tmpCanvas, 0, 0, canvasWidth, canvasHeight);
        }

    }, [imageObject, crop, filter, adjustments, format, quality, lossless,
        isCropping, cropRounding, canvasWidth, canvasHeight]);

    useImperativeHandle(ref, () => ({
        getConfirmationData: () => {
            return {
                interactiveCrop: currentInteractiveCropFromHook,
                scale: currentScale,
            };
        }
    }), [currentInteractiveCropFromHook, currentScale])

    return (
        <div
            ref={containerRef}
            style={{ width: "100%", position: "relative", minHeight: "100px", overflow: "hidden" }}
            className="bg-gray-100 dark:bg-gray-900"
        >
            <canvas
                ref={canvasRef}
                className="block w-full h-auto shadow-md"
                style={{ display: 'block' }}
            />
            <div
                ref={overlayRef}
                {...overlayProps}
            >
                <div
                    {...handleProps}
                ></div>
            </div>
        </div>
    );
});

export default ImageCanvas;
</file>

<file path="src/components/controls/ExportControls.jsx">
import React, { useEffect } from "react";
import { FORMAT_OPTIONS } from "../../constants/exportOptions";
import { useEditingContext } from "../../context/EditingContext";

const ExportControls = () => {
    const {
        format, quality, lossless, isExporting,
        setFormat, setQuality, setLossless,
        startExport,
        originalImage, crop, selectedFilter, adjustments, cropRounding, file, hasImage,
        enableResizing, setEnableResizing,
        targetWidth, setTargetWidth,
        targetHeight, setTargetHeight,
        keepAspectRatio, setKeepAspectRatio,
    } = useEditingContext();
    if (!hasImage) return null;

    const currentFormat = FORMAT_OPTIONS.find((f) => f.value === format);
    const getOriginalDims = () => {
        if (!originalImage) return null;
        if (originalImage instanceof HTMLImageElement) {
            return { w: originalImage.naturalWidth, h: originalImage.naturalHeight };
        } else if (originalImage instanceof HTMLCanvasElement) {
            return { w: originalImage.width, h: originalImage.height };
        }
        return null;
    }
    const originalDims = getOriginalDims();

    const getFiletypeDisplay = () => {
        if (!file) return '';
        return file.type || file.name.split('.').pop()?.toUpperCase() || 'Unknown';
    };

    const showQuality = currentFormat.lossy && (!currentFormat.supportsLossless || !lossless);
    const showLossless = currentFormat.supportsLossless;

    const handleDimensionChange = (dimension, value) => {
        const numValue = parseInt(value, 10);
        const isValidNum = !isNaN(numValue) && numValue > 0;
        const canCalculateRatio = crop?.width > 0 && crop?.height > 0;

        if (dimension === 'width') {
            setTargetWidth(value);
            if (keepAspectRatio && isValidNum && canCalculateRatio) {
                const ratio = crop.height / crop.width;
                setTargetHeight(String(Math.round(numValue * ratio)));
            }
        } else if (dimension === 'height') {
            setTargetHeight(value);
            if (keepAspectRatio && isValidNum && canCalculateRatio) {
                const ratio = crop.width / crop.height;
                setTargetWidth(String(Math.round(numValue * ratio)));
            }
        }
    };

    useEffect(() => {
        if (enableResizing && crop) {
            if (targetWidth === '') setTargetWidth(String(Math.round(crop.width)));
            if (targetHeight === '') setTargetHeight(String(Math.round(crop.height)));
        }
    }, [enableResizing, crop, targetWidth, targetHeight, setTargetWidth, setTargetHeight]);

    const handleExportClick = () => {
        if (!originalImage || !crop || !file) {
            return;
        }
        startExport({
            image: originalImage,
            crop,
            filter: selectedFilter,
            adjustments,
            rounding: cropRounding,
            originalFilename: file.name,
        });
    };

    return (
        <div className="p-4 bg-gray-200 dark:bg-gray-800 rounded-xl shadow-md mt-4 space-y-4">
            <div className="flex flex-col sm:flex-row sm:items-center gap-4">
                <label className="text-sm font-medium text-gray-700 dark:text-gray-300">
                    Export Format:
                </label>
                <select
                    className="flex-1 bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500 text-gray-800 dark:text-gray-100"
                    value={format}
                    onChange={(e) => setFormat(e.target.value)}
                >
                    {FORMAT_OPTIONS.map((option) => (
                        <option key={option.value} value={option.value}>
                            {option.label}
                        </option>
                    ))}
                </select>
            </div>

            {(originalDims || file) && (
                <div className="text-xs text-gray-600 dark:text-gray-300 border-t border-gray-300 dark:border-gray-600 pt-2 mt-2">
                    {originalDims && `Original Size: ${originalDims.w} x ${originalDims.h} px`}
                    {originalDims && file && ' | '}
                    {file && `Type: ${getFiletypeDisplay()}`}
                    <br />
                    {crop && `Current Crop Size: ${Math.round(crop.width)}  x ${Math.round(crop.height)} px`}
                </div>
            )}

            <div className="border-t border-gray-300 dark:border-gray-600 pt-4 space-y-3">
                <div className="flex items-center">
                    <input
                        id="enableResize"
                        type="checkbox"
                        checked={enableResizing}
                        onChange={(e) => setEnableResizing(e.target.checked)}
                        className="mr-2 h-4 w-4 rounnded border-gray-300 text-blue-600 focus:ring-blue-500 dark:border-gray-600 dark:bg-gray-700 dark:focus:ring-blue-600 dark:ring-offset-gray-800"
                        disabled={isExporting}
                    />
                    <label htmlFor="enableResize" className="text-sm font-medium text-gray-700 dark:text-gray-300">
                        Resize Output Image
                    </label>
                </div>

                {enableResizing && (
                    <div className="space-y-3 pl-6 border-l-2 border-gray-300 dark:border-gray-500 ml-2">
                        <div className="grid grid-cols-[auto_1fr_auto] gap-x-2 gap-y-3 items-center">
                            <label htmlFor="targetWidth" className="text-xs text-gray-600 dark:text-gray-400">W:</label>
                            <input
                                id="targetWidth"
                                type="number"
                                min="1"
                                placeholder={crop ? String(Math.round(crop.width)) : 'auto'}
                                value={targetWidth}
                                onChange={(e) => handleDimensionChange('width', e.target.value)}
                                className="w-full text-sm rounded px-2 py-1 border border-gray-300 dark:border-gray-500 bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100 focus:outline-none focus:ring-1 focus:ring-blue-400 disabled:bg-gray-200 dark:disabled:bg-gray-600 disabled:text-gray-500 disabled:cursor-not-allowed"
                                disabled={isExporting}
                            />
                            <span className="text-xs text-gray-500 dark:text-gray-400">px</span>

                            <label htmlFor="targetHeight" className="text-xs text-gray-600 dark:text-gray-400">H:</label>
                            <input
                                id="targetHeight"
                                type="number"
                                min="1"
                                placeholder={crop ? String(Math.round(crop.height)) : 'auto'}
                                value={targetHeight}
                                onChange={(e) => handleDimensionChange('height', e.target.value)}
                                className="w-full text-sm rounded px-2 py-1 border border-gray-300 dark:border-gray-500 bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100 focus:outline-none focus:ring-1 focus:ring-blue-400 disabled:bg-gray-200 dark:disabled:bg-gray-600 disabled:text-gray-500 disabled:cursor-not-allowed"
                                disabled={isExporting}
                            />
                            <span className="text-xs text-gray-500 dark:text-gray-400">px</span>
                        </div>
                        <div className="flex items-center pt-1">
                            <input
                                id="keepRatio"
                                type="checkbox"
                                checked={keepAspectRatio}
                                onChange={(e) => setKeepAspectRatio(e.target.checked)}
                                className="mr-2 h-4 w-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500 dark:border-gray-600 dark:bg-gray-700 dark:focus:ring-blue-600 dark:ring-offset-gray-800"
                                disabled={isExporting}
                            />
                            <label htmlFor="keepRatio" className="text-xs font-medium text-gray-600 dark:text-gray-400">Keep Aspect Ratio</label>
                            <button
                                onClick={() => {
                                    if (crop) {
                                        setTargetWidth(String(Math.round(crop.width)));
                                        setTargetHeight(String(Math.round(crop.height)));
                                    }
                                }}
                                className="ml-auto text-xs text-blue-600 hover:text-blue-800 dark:text-blue-400 dark:hover:text-blue-300 disabled:opacity-50"
                                title="Reset dimensions to current crop size"
                                disabled={isExporting || !crop}
                            >
                                Reset
                            </button>
                        </div>
                    </div>
                )}
            </div>

            {showLossless && (
                <div className="flex items-center gap-2">
                    <label className="text-sm font-medium text-gray-700 dark:text-gray-300">
                        Lossless:
                    </label>
                    <input
                        type="checkbox"
                        checked={lossless}
                        onChange={(e) => setLossless(e.target.checked)}
                    />
                </div>
            )}

            {showQuality && (
                <div className="flex flex-col gap-2">
                    <label className="text-sm font-medium text-gray-700 dark:text-gray-300">
                        Quality: {Math.round(quality)}%
                    </label>
                    <input
                        type="range"
                        min={1}
                        max={100}
                        step={1}
                        className="w-full accent-blue-500 cursor-pointer"
                        value={quality}
                        onChange={(e) => setQuality(parseFloat(e.target.value, 10))}
                    />
                </div>
            )}

            <button
                className={`w-full text-white py-2 rounded-lg transition shadow-sm ${isExporting ? 'bg-gray-500 cursor-not-allowed' : 'bg-blue-600 hover:bg-blue-700'}`}
                onClick={handleExportClick}
                disabled={isExporting}
            >
                {isExporting ? 'Exporting...' : 'Download Edited Image'}
            </button>
        </div>
    );
};

export default ExportControls;
</file>

<file path="src/components/sidebar/AdjustmentsPanel.jsx">
import React from "react";
import { useEditingContext } from "../../context/EditingContext";
import { adjustmentConfigs, initialAdjustments } from "../../constants/adjustments";

const AdjustmentsPanel = () => {
    const { adjustments, setAdjustments, hasImage } = useEditingContext();
    const isDisabled = !hasImage;
    const handleChange = (key, value) => {
        setAdjustments((prev) => ({ ...prev, [key]: value }));
    };

    const handleReset = () => {
        setAdjustments(initialAdjustments);
    };

    return (
        <div className="p-2 space-y-4">
            {adjustmentConfigs.map(config => (
                <div key={config.key}>
                    <label className="block mb-1 text-sm font-medium text-gray-700 dark:text-gray-300">
                        {config.label} ({adjustments[config.key]}{config.unit})
                    </label>
                    <input
                        type="range"
                        min={config.min}
                        max={config.max}
                        value={adjustments[config.key]}
                        onChange={(e) => handleChange(config.key, parseInt(e.target.value))}
                        className={`w-full accent-blue-500 cursor-pointer ${isDisabled ? 'opacity-50 cursor-not-allowed' : ''}`}
                        disabled={isDisabled}
                    />
                </div>
            ))}
            <button
                onClick={handleReset}
                className={`w-full bg-red-500 hover:bg-red-600 text-white py-1 rounded ${isDisabled ? 'opacity-50 cursor-not-allowed' : ''}`}
                disabled={isDisabled}
            >
                Reset Adjustments
            </button>
        </div>
    );
};

export default AdjustmentsPanel;
</file>

<file path="src/components/sidebar/CropPanel.jsx">
import React, { useState, useEffect } from "react";
import { useEditingContext } from "../../context/EditingContext";
import { cropPresets } from "../../constants/cropPresets";

const CropPanel = () => {
    const {
        aspectRatio, setAspectRatio, isCropping, startCroppingSession,
        cropRounding, setCropRounding, lockAspectRatio, setLockAspectRatio,
        confirmCrop, cancelCrop, hasImage
    } = useEditingContext();

    const [customRatioW, setCustomRatioW] = useState(1);
    const [customRatioH, setCustomRatioH] = useState(1);

    useEffect(() => {
        if (aspectRatio) {
            setCustomRatioW(aspectRatio.toFixed(2));
            setCustomRatioH((1).toFixed(2));
        } else {
            setCustomRatioW(1);
            setCustomRatioH(1);
        }
    }, [aspectRatio]);

    const handlePresetClick = (ratio) => {
        setAspectRatio(ratio);
        setLockAspectRatio(true);
        if (hasImage) {
            startCroppingSession();
        }
    };

    const handleFreeformClick = () => {
        setAspectRatio(null);
        setLockAspectRatio(false);
        if (hasImage) {
            startCroppingSession();
        }
    }

    const handleCustomRatioChange = (w, h) => {
        const width = parseFloat(w) || 0;
        const height = parseFloat(h) || 0;
        setCustomRatioW(w);
        setCustomRatioH(h);

        if (width > 0 && height > 0) {
            setAspectRatio(width / height);
            if (hasImage) {
                startCroppingSession();
            }
        } else {
            setAspectRatio(null);
        }
    };

    const handleRoundingChange = (e) => { const value = parseInt(e.target.value, 10); setCropRounding(Math.max(0, Math.min(50, value || 0))); };
    const handleRoundingInputChange = (e) => { const value = parseInt(e.target.value, 10); setCropRounding(Math.max(0, Math.min(50, value || 0))); };

    const controlsDisabled = !hasImage;
    const roundingDisabled = !isCropping || !hasImage;
    const lockDisabled = !isCropping || !hasImage || aspectRatio === null;
    const customRatioDisabled = (lockAspectRatio && aspectRatio !== null) || !hasImage;


    return (
        <div className="space-y-4">
            <p className="text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">Presets</p>
            <div className="flex flex-wrap gap-2">
                {cropPresets.map((preset) => (
                    <button
                        key={preset.name}
                        onClick={() => handlePresetClick(preset.ratio)}
                        className={`px-2 py-1 text-white rounded ${preset.color} ${aspectRatio === preset.ratio && isCropping ? 'ring-2 ring-offset-1 ring-offset-gray-800 ring-white' : ''} disabled:opacity-50 disabled:cursor-not-allowed`}
                        disabled={controlsDisabled}
                    >
                        {preset.name}
                    </button>
                ))}
                <button
                    onClick={handleFreeformClick}
                    className={`px-2 py-1 rounded bg-gray-500 hover:bg-gray-600 text-white ${aspectRatio === null && isCropping ? 'ring-2 ring-offset-1 ring-offset-gray-800 ring-white' : ''} disabled:opacity-50 disabled:cursor-not-allowed`}
                    disabled={controlsDisabled}
                >
                    Freeform
                </button>
            </div>
            <div className="flex items-center gap-2">
                <span className={`text-sm ${customRatioDisabled ? 'text-gray-400 dark:text-gray-500' : 'text-gray-700 dark:text-gray-300'}`}>Custom Ratio:</span>
                <input
                    type="number" step="0.1" min="0.1"
                    value={customRatioW}
                    onChange={(e) => handleCustomRatioChange(e.target.value, customRatioH)}
                    className="w-16 text-center rounded px-1 py-0.5 border border-gray-300 dark:border-gray-500 bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100 focus:outline-none focus:ring-1 focus:ring-blue-400 disabled:bg-gray-200 dark:disabled:bg-gray-600 disabled:text-gray-500 disabled:cursor-not-allowed"
                    disabled={customRatioDisabled}
                />
                <span className={`text-sm ${customRatioDisabled ? 'text-gray-400 dark:text-gray-500' : 'text-gray-700 dark:text-gray-300'}`}>:</span>
                <input
                    type="number" step="0.1" min="0.1"
                    value={customRatioH}
                    onChange={(e) => handleCustomRatioChange(customRatioW, e.target.value)}
                    className="w-16 text-center rounded px-1 py-0.5 border border-gray-300 dark:border-gray-500 bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100 focus:outline-none focus:ring-1 focus:ring-blue-400 disabled:bg-gray-200 dark:disabled:bg-gray-600 disabled:text-gray-500 disabled:cursor-not-allowed"
                    disabled={customRatioDisabled}
                />
            </div>
            <div>
                <div className="flex items-center justify-between mb-1">
                    <label className={`block text-sm font-medium ${roundingDisabled ? 'text-gray-400 dark:text-gray-500' : 'text-gray-700 dark:text-gray-300'}`}>Crop Rounding (%)</label>
                    <input
                        type="number" min="0" max="50" step="1"
                        value={cropRounding}
                        onChange={handleRoundingInputChange}
                        className="w-16 text-center rounded px-1 py-0.5 border border-gray-300 dark:border-gray-500 bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100 focus:outline-none focus:ring-1 focus:ring-blue-400 disabled:bg-gray-200 dark:disabled:bg-gray-600 disabled:text-gray-500 disabled:cursor-not-allowed"
                        disabled={roundingDisabled}
                    />
                </div>
                <input
                    type="range" min="0" max="50" step="1"
                    value={cropRounding}
                    onChange={handleRoundingChange}
                    className="w-full accent-blue-500 cursor-pointer disabled:opacity-50 disabled:cursor-not-allowed"
                    disabled={roundingDisabled}
                />
            </div>
            <div className="flex items-center">
                <input
                    id="lockAspect" type="checkbox"
                    checked={lockAspectRatio}
                    onChange={(e) => setLockAspectRatio(e.target.checked)}
                    className="mr-2 h-4 w-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500 dark:border-gray-600 dark:bg-gray-700 dark:focus:ring-blue-600 dark:ring-offset-gray-800 disabled:opacity-50 disabled:cursor-not-allowed"
                    disabled={lockDisabled}
                />
                <label htmlFor="lockAspect" className={`text-sm ${lockDisabled ? 'text-gray-400 dark:text-gray-500' : 'text-gray-700 dark:text-gray-300'}`}>Lock Aspect Ratio</label>
            </div>
            <div className="flex gap-2 pt-4 border-t border-gray-300 dark:border-gray-600">
                <button
                    onClick={confirmCrop}
                    className="flex-1 bg-green-500 text-white py-2 rounded hover:bg-green-600 text-sm transition duration-150 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed disabled:hover:bg-green-500"
                    disabled={!isCropping}
                >
                    Confirm Crop
                </button>
                <button
                    onClick={cancelCrop}
                    className="flex-1 bg-red-500 text-white py-2 rounded hover:bg-red-600 text-sm transition duration-150 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed disabled:hover:bg-red-500"
                    disabled={!isCropping}
                >
                    Cancel Crop
                </button>
            </div>
        </div>
    );
};

export default CropPanel;
</file>

<file path="src/components/sidebar/FiltersPanel.jsx">
import React from "react";
import { useEditingContext } from "../../context/EditingContext";

import { filtersList } from "../../constants/filters";

const FiltersPanel = () => {
    const { selectedFilter, setSelectedFilter, hasImage } = useEditingContext();
    const isDisabled = !hasImage;

    return (
        <div className="p-2">
            <div className="flex flex-wrap gap-2">
                {filtersList.map((filter) => (
                    <button
                        key={filter.name}
                        className={`${filter.className} ${selectedFilter === filter.name ? "ring-2 ring-blue-500" : ""
                            } ${isDisabled ? 'opacity-50 cursor-not-allowed' : ''}`}
                        onClick={() => setSelectedFilter(filter.name)}
                    >
                        {filter.name}
                    </button>
                ))}
            </div>
        </div>
    );
};

export default FiltersPanel;
</file>

<file path="src/components/sidebar/Sidebar.jsx">
import React, { useState } from "react";
import CropPanel from "./CropPanel";
import AdjustmentsPanel from "./AdjustmentsPanel";
import FiltersPanel from "./FiltersPanel";

const Sidebar = () => {
    const [activeTab, setActiveTab] = useState("crop");

    const renderActivePanel = () => {
        switch (activeTab) {
            case "crop":
                return (
                    <CropPanel />
                );
            case "adjustments":
                return <AdjustmentsPanel />;
            case "filters":
                return <FiltersPanel />;
            default:
                return null;
        }
    };
    return (
        <div className="w-full md:w-80">
            <div className="bg-white dark:bg-gray-800 p-2 shadow-md rounded">
                <div className="flex border-b border-gray-300 dark:border-gray-600 mb-2">
                    <button
                        className={`flex-1 py-2 text-center text-sm ${activeTab === "crop" ? "border-b-2 border-blue-500 text-blue-500 font-medium" : "text-gray-600 dark:text-gray-300 hover:text-gray-800 dark:hover:text-gray-100"}`}
                        onClick={() => setActiveTab("crop")}
                    >
                        Crop
                    </button>
                    <button
                        className={`flex-1 py-2 text-center text-sm ${activeTab === "adjustments" ? "border-b-2 border-blue-500 text-blue-500 font-medium" : "text-gray-600 dark:text-gray-300 hover:text-gray-800 dark:hover:text-gray-100"}`}
                        onClick={() => setActiveTab("adjustments")}
                    >
                        Adjustments
                    </button>
                    <button
                        className={`flex-1 py-2 text-center text-sm ${activeTab === "filters" ? "border-b-2 border-blue-500 text-blue-500 font-medium" : "text-gray-600 dark:text-gray-300 hover:text-gray-800 dark:hover:text-gray-100"}`}
                        onClick={() => setActiveTab("filters")}
                    >
                        Filters
                    </button>
                </div>
                <div className="p-2 min-h-[100px]">
                    {renderActivePanel()}
                </div>
            </div>
        </div>
    );
};

export default Sidebar;
</file>

<file path="src/components/ui/FileUpload.jsx">
import React, { useState, useRef, useCallback } from "react";

const FileUpload = ({ onFileSelected, children, clickable = true, hideBorder = false }) => {
    const [dragActive, setDragActive] = useState(false);
    const fileInputRef = useRef(null);

    const handleDragEnter = useCallback((event) => {
        event.preventDefault();
        event.stopPropagation();
        setDragActive(true);
    }, []);

    const handleDragOver = useCallback((event) => {
        event.preventDefault();
        event.stopPropagation();
        if (!dragActive) {
            setDragActive(true);
        }
    }, [dragActive]);

    const handleDragLeave = useCallback((event) => {
        event.preventDefault();
        event.stopPropagation();
        setDragActive(false);
    }, []);

    const handleDrop = useCallback((event) => {
        event.preventDefault();
        event.stopPropagation();
        setDragActive(false);
        const { files } = event.dataTransfer;
        if (files && files[0]) {
            onFileSelected?.(files[0]);
        }
    }, [onFileSelected]);

    const handleFileChange = useCallback((event) => {
        const file = event.target.files[0];
        if (file) {
            onFileSelected?.(file);
        }
    }, [onFileSelected]);

    const handleClick = useCallback(() => {
        fileInputRef.current?.click();
    }, []);

    const containerClassName = hideBorder
        ? 'relative'
        : `relative border-2 border-dashed text-center rounded-lg transition-colors p-8 ${dragActive ? 'border-blue-500' : 'border-gray-300'}`;

    return (
        <div
            onClick={clickable ? handleClick : undefined}
            onDragEnter={handleDragEnter}
            onDragOver={handleDragOver}
            onDragLeave={handleDragLeave}
            onDrop={handleDrop}
            className={containerClassName}
        >
            {children}
            <input
                ref={fileInputRef}
                type="file"
                accept="image/jpeg,image/png,image/gif,image/bmp,image/webp,image/tiff,.tif,.tiff,image/avif"
                className="hidden"
                onChange={handleFileChange}
            />
        </div>
    );
};

export default FileUpload;
</file>

<file path="src/components/ui/Header.jsx">
import React, { useState, useEffect } from "react";
import ThemeToggleButton from "./ThemeToggleButton";

const Header = () => {
    return (
        <header className="bg-gray-800 dark:bg-gray-700 text-white py-3 px-4 shadow-md sticky top-0 z-50">
            <div className="max-w-6xl mx-auto text-center flex justify-between items-center">
                <a href="/" className="text-2xl font-semibold hover:opacity-90">
                    imgStyler
                </a>
                <nav className="flex items-center space-x-4 md:space-x-6">
                    <a
                        href="/"
                        className="text-sm md:text-base hover:text-blue-300 transition-colors"
                    >
                        Home
                    </a>
                    <a
                        href="/features"
                        className="text-sm md:text-base hover:text-blue-300 transition-colors"
                    >
                        Features
                    </a>
                    <a
                        href="/about"
                        className="text-sm md:text-base hover:text-blue-300 transition-colors"
                    >
                        About
                    </a>
                    <a
                        href="/contact"
                        className="text-sm md:text-base hover:text-blue-300 transition-colors"
                    >
                        Contact
                    </a>
                </nav>
                <ThemeToggleButton client:idle />
            </div>
        </header>
    );
};

export default Header;
</file>

<file path="src/components/ui/ThemeToggleButton.jsx">
import React, { useState, useEffect, useCallback } from "react";

const getInitialClientDarkMode = () => {
    if (typeof window === 'undefined') {
        return null;
    }
    const storedPreference = localStorage.getItem('isDarkMode');
    return storedPreference ? JSON.parse(storedPreference) : true;
}

const ThemeToggleButton = () => {
    const [isDarkMode, setIsDarkMode] = useState(() => {
        if (typeof window !== 'undefined') {
            const storedPreference = localStorage.getItem('isDarkMode');
            return storedPreference ? JSON.parse(storedPreference) : true;
        }
        return true;
    });

    useEffect(() => {
        localStorage.setItem('isDarkMode', JSON.stringify(isDarkMode));
        if (isDarkMode) {
            document.documentElement.classList.add('dark');
        } else {
            document.documentElement.classList.remove('dark');
        }
    }, [isDarkMode]);

    const toggleDarkMode = () => {
        setIsDarkMode(prev => !prev);
    };

    const [isMounted, setIsMounted] = useState(false);
    useEffect(() => {
        setIsMounted(true);
    }, []);


    return (
        <button
            onClick={toggleDarkMode}
            className="bg-gray-600 dark:bg-gray-500 px-3 py-1 rounded text-sm"
            aria-label={isDarkMode ? 'Activate Light Mode' : 'Activate Dark Mode'}
        >
            {isMounted ? (isDarkMode ? 'Light Mode' : 'Dark Mode') : 'Light Mode'}
        </button>
    );
};

export default ThemeToggleButton;
</file>

<file path="src/components/InteractiveImage.jsx">
import React, { useState, useRef, useCallback } from "react";
import FileUpload from "./ui/FileUpload";
import ImageCanvas from "./canvas/ImageCanvas";
import ExportControls from "./controls/ExportControls";
import Sidebar from "./sidebar/Sidebar";
import { useImageLoader } from "../hooks/useImageLoader";
import { useCroppingState } from "../hooks/useCroppingState";
import { useExportManager } from "../hooks/useExportManager";
import { initialAdjustments } from "../constants/adjustments";
import { EditingProvider } from "../context/EditingContext";

const InteractiveImage = () => {
    const [selectedFilter, setSelectedFilter] = useState("None")
    const [adjustments, setAdjustments] = useState(initialAdjustments);
    const { file, setFile, originalImage, isLoading, imageLoadError } = useImageLoader();
    const {
        crop, isCropping, aspectRatio, setAspectRatio, cropRounding, setCropRounding,
        lockAspectRatio, setLockAspectRatio, startCroppingSession, confirmCrop, cancelCrop
    } = useCroppingState(originalImage);
    const exportManager = useExportManager();
    const imageCanvasRef = useRef(null);

    const handleConfirmCrop = useCallback(() => {
        const confirmationData = imageCanvasRef.current?.getConfirmationData();
        if (confirmationData?.interactiveCrop && confirmationData?.scale > 0) {
            confirmCrop(confirmationData.interactiveCrop, confirmationData.scale);
        } else {
            cancelCrop();
        }
    }, [confirmCrop, cancelCrop]);

    const handleCancelCrop = useCallback(() => {
        cancelCrop();
    }, [cancelCrop]);

    const editingContextValue = {
        crop,
        originalImage,
        file,
        hasImage: !!originalImage && !isLoading && !imageLoadError,
        selectedFilter,
        setSelectedFilter,
        adjustments,
        setAdjustments,
        isCropping,
        aspectRatio,
        setAspectRatio,
        cropRounding,
        setCropRounding,
        lockAspectRatio,
        setLockAspectRatio,
        startCroppingSession,
        confirmCrop: handleConfirmCrop,
        cancelCrop: handleCancelCrop,
        format: exportManager.format,
        setFormat: exportManager.setFormat,
        quality: exportManager.quality,
        setQuality: exportManager.setQuality,
        lossless: exportManager.lossless,
        setLossless: exportManager.setLossless,
        isExporting: exportManager.isExporting,
        startExport: exportManager.startExport,
        exportError: exportManager.exportError,
        clearExportError: exportManager.clearExportError,
        enableResizing: exportManager.enableResizing,
        setEnableResizing: exportManager.setEnableResizing,
        targetWidth: exportManager.targetWidth,
        setTargetWidth: exportManager.setTargetWidth,
        targetHeight: exportManager.targetHeight,
        setTargetHeight: exportManager.setTargetHeight,
        keepAspectRatio: exportManager.keepAspectRatio,
        setKeepAspectRatio: exportManager.setKeepAspectRatio,
    };

    return (
        <div className="flex flex-col md:flex-row w-full max-w-6xl mx-auto space-y-6 md:space-y-0 md:space-x-6">
            <div className="flex-1">
                <div className={`relative ${isCropping ? 'pointer-events-none' : ''}`}>
                    <FileUpload onFileSelected={setFile} clickable={true} hideBorder={!!originalImage}>
                        {originalImage && crop ? (
                            <ImageCanvas
                                ref={imageCanvasRef}
                                imageObject={originalImage}
                                crop={crop}
                                filter={selectedFilter}
                                adjustments={adjustments}
                                format={exportManager.format}
                                quality={exportManager.quality}
                                lossless={exportManager.lossless}
                                isCropping={isCropping}
                                aspectRatio={aspectRatio}
                                cropRounding={cropRounding}
                                lockAspectRatio={lockAspectRatio}
                            />
                        ) : isLoading ? (
                            <div className="flex items-center justify-center p-10 rounded-lg text-center min-h-[300px] bg-gray-100 dark:bg-gray-900">
                                Loading image...
                            </div>
                        ) : imageLoadError ? (
                            <div className="flex flex-col items-center justify-center p-10 rounded-lg text-center min-h-[300px] bg-red-100 dark:bg-red-900 border border-red-500 text-red-700 dark:text-red-200">
                                <p className="font-semibold">Image Load Error</p>
                                <p className="mt-2">{imageLoadError}</p>
                                <button
                                    onClick={() => setFile(null)}
                                    className="mt-4 bg-red-500 text-white py-1 px-3 rounded hover:bg-red-600"
                                >
                                    Clear Selection
                                </button>
                            </div>
                        ) : (
                            <div className="flex flex-col items-center justify-center p-10 rounded-lg text-center min-h-[300px] cursor-pointer bg-gray-100 dark:bg-gray-900">
                                <p className="mb-4 text-lg text-gray-800 dark:text-gray-100">
                                    Drag & Drop an image here, or click to select a file
                                </p>
                                <button className="bg-blue-600 text-white py-2 px-4 rounded hover:bg-blue-700 pointer-events-none">
                                    Choose File
                                </button>
                            </div>
                        )}
                    </FileUpload>
                    {originalImage && !isLoading && !imageLoadError && !isCropping && (
                        <p className="mt-2 text-center text-xs text-gray-500 dark:text-gray-400">
                            Click image or drag in a new file to replace.
                        </p>
                    )}

                    <div className={!originalImage || isLoading || imageLoadError ? 'opacity-50 pointer-events-none' : ''}>
                        <EditingProvider value={editingContextValue}>
                            {originalImage && !isLoading && !imageLoadError && (
                                <ExportControls />
                            )}
                        </EditingProvider>
                    </div>

                </div>
            </div>

            <EditingProvider value={editingContextValue}>
                <Sidebar />
            </EditingProvider>
        </div>
    );
};

export default InteractiveImage;
</file>

<file path="src/constants/adjustments.js">
export const adjustmentConfigs = [
  {
    key: "brightness",
    label: "Brightness",
    unit: "%",
    min: 50,
    max: 150,
    defaultValue: 100,
  },
  {
    key: "contrast",
    label: "Contrast",
    unit: "%",
    min: 50,
    max: 150,
    defaultValue: 100,
  },
  {
    key: "saturation",
    label: "Saturation",
    unit: "%",
    min: 50,
    max: 150,
    defaultValue: 100,
  },
  { key: "hue", label: "Hue", unit: "°", min: -180, max: 180, defaultValue: 0 },
  {
    key: "sharpness",
    label: "Sharpness",
    unit: "",
    min: -100,
    max: 100,
    defaultValue: 0,
  },
  {
    key: "temperature",
    label: "Temperature",
    unit: "",
    min: -100,
    max: 100,
    defaultValue: 0,
  },
  {
    key: "tint",
    label: "Tint",
    unit: "",
    min: -100,
    max: 100,
    defaultValue: 0,
  },
];

export const initialAdjustments = adjustmentConfigs.reduce((acc, config) => {
  acc[config.key] = config.defaultValue;
  return acc;
}, {});
</file>

<file path="src/constants/cropPresets.js">
export const cropPresets = [
  {
    name: "Instagram (1:1)",
    ratio: 1 / 1,
    color: "bg-indigo-500 hover:bg-indigo-600",
  },
  {
    name: "Instagram (4:5)",
    ratio: 4 / 5,
    color: "bg-orange-500 hover:bg-orange-600",
  },
  {
    name: "Instagram (1.91:1)",
    ratio: 1.91 / 1,
    color: "bg-yellow-500 hover:bg-yellow-600 text-black",
  },
  {
    name: "Twitter (16:9)",
    ratio: 16 / 9,
    color: "bg-teal-500 hover:bg-teal-600",
  },
  {
    name: "Facebook (1.91:1)",
    ratio: 1.91 / 1,
    color: "bg-blue-700 hover:bg-blue-800",
  },
  {
    name: "Pinterest (2:3)",
    ratio: 2 / 3,
    color: "bg-pink-500 hover:bg-pink-600",
  },
  {
    name: "Snapchat (9:16)",
    ratio: 9 / 16,
    color: "bg-purple-600 hover:bg-purple-700",
  },
  {
    name: "LinkedIn (1.91:1)",
    ratio: 1.91 / 1,
    color: "bg-blue-600 hover:bg-blue-700",
  },
  {
    name: "TikTok (9:16)",
    ratio: 9 / 16,
    color: "bg-red-600 hover:bg-red-700",
  },
];
</file>

<file path="src/constants/exportOptions.js">
export const FORMAT_OPTIONS = [
  {
    label: "PNG (Lossless)",
    value: "image/png",
    lossy: false,
    supportsLossless: false,
  },
  {
    label: "JPEG (Lossy)",
    value: "image/jpeg",
    lossy: true,
    supportsLossless: false,
  },
  { label: "WebP", value: "image/webp", lossy: true, supportsLossless: true },
  {
    label: "TIFF (Lossless)",
    value: "image/tiff",
    lossy: false,
    supportsLossless: false,
  },
];
</file>

<file path="src/constants/filters.js">
export const filtersList = [
  {
    name: "None",
    className:
      "py-1 px-3 rounded hover:bg-gray-400 dark:hover:bg-gray-500 bg-gray-300 dark:bg-gray-600 text-gray-800 dark:text-gray-200",
  },
  {
    name: "Grayscale",
    className: "py-1 px-3 rounded hover:bg-blue-600 bg-blue-500 text-white",
  },
  {
    name: "Vintage",
    className: "py-1 px-3 rounded hover:bg-yellow-600 bg-yellow-500 text-white",
  },
  {
    name: "Vibrant",
    className: "py-1 px-3 rounded hover:bg-green-600 bg-green-500 text-white",
  },
  {
    name: "Soft Focus",
    className: "py-1 px-3 rounded hover:bg-purple-600 bg-purple-500 text-white",
  },
  {
    name: "Noir",
    className: "py-1 px-3 rounded hover:bg-gray-900 bg-black text-white",
  },
  {
    name: "Sepia",
    className: "py-1 px-3 rounded hover:bg-amber-700 bg-amber-600 text-white",
  },
  {
    name: "Invert",
    className: "py-1 px-3 rounded hover:bg-red-600 bg-red-500 text-white",
  },
  {
    name: "Polaroid",
    className: "py-1 px-3 rounded hover:bg-rose-400 bg-rose-300 text-white",
  },
  {
    name: "Sketch",
    className: "py-1 px-3 rounded hover:bg-indigo-600 bg-indigo-500 text-white",
  },
];
</file>

<file path="src/context/EditingContext.js">
import React, { createContext, useContext } from "react";

const EditingContext = createContext(null);

export function useEditingContext() {
  const context = useContext(EditingContext);
  if (!context) {
    throw new Error("useEditingContext must be used within an EditingProvider");
  }
  return context;
}

export const EditingProvider = EditingContext.Provider;
</file>

<file path="src/hooks/useCanvasDisplaySize.js">
import { useState, useEffect, useMemo } from "react";

const DEFAULT_SIZE = { width: 0, height: 0, scale: 1 };

export function useCanvasDisplaySize(containerRef, crop, imageObject) {
  const [containerWidth, setContainerWidth] = useState(0);
  const [displaySize, setDisplaySize] = useState(DEFAULT_SIZE);

  useEffect(() => {
    const container = containerRef.current;
    if (!container) {
      setContainerWidth(0);
      return;
    }

    const observer = new ResizeObserver((entries) => {
      if (entries[0]) {
        setContainerWidth(entries[0].contentRect.width);
      }
    });

    observer.observe(container);
    setContainerWidth(container.clientWidth);
    return () => {
      if (container) {
        observer.unobserve(container);
      }
      observer.disconnect();
    };
  }, [containerRef]);

  useEffect(() => {
    if (!crop || !imageObject || containerWidth <= 0) {
      setDisplaySize(DEFAULT_SIZE);
      return;
    }

    const cropWidth = crop.width || 1;
    const cropHeight = crop.height || 1;
    const imageWidth = imageObject.width || imageObject.naturalWidth || 1;
    const imageHeight = imageObject.height || imageObject.naturalHeight || 1;

    let cropAspectRatio = cropWidth / cropHeight;
    if (
      isNaN(cropAspectRatio) ||
      !isFinite(cropAspectRatio) ||
      cropAspectRatio <= 0
    ) {
      cropAspectRatio = imageWidth / imageHeight;
      if (
        isNaN(cropAspectRatio) ||
        !isFinite(cropAspectRatio) ||
        cropAspectRatio <= 0
      ) {
        cropAspectRatio = 1;
      }
    }

    let targetWidth = containerWidth;
    let targetHeight = targetWidth / cropAspectRatio;
    targetWidth = Math.max(1, Math.round(targetWidth));
    targetHeight = Math.max(1, Math.round(targetHeight));
    const scale = targetWidth / cropWidth;

    setDisplaySize({
      width: targetWidth,
      height: targetHeight,
      scale: isFinite(scale) ? scale : 1,
    });
  }, [containerWidth, crop, imageObject]);

  return displaySize;
}
</file>

<file path="src/hooks/useCroppingState.js">
import { useState, useEffect, useCallback } from "react";

const getInitialCrop = (image) => {
  if (!image) return null;
  return { x: 0, y: 0, width: image.width, height: image.height };
};

export function useCroppingState(originalImage) {
  const [crop, setCrop] = useState(() => getInitialCrop(originalImage));
  const [isCropping, setIsCropping] = useState(false);
  const [cropSessionStartCrop, setCropSessionStartCrop] = useState(null);

  const [aspectRatio, setAspectRatio] = useState(null);
  const [cropRounding, setCropRounding] = useState(0);
  const [lockAspectRatio, setLockAspectRatio] = useState(true);

  useEffect(() => {
    const initialCrop = getInitialCrop(originalImage);
    setCrop(initialCrop);
    setIsCropping(false);
    setCropSessionStartCrop(null);
    setAspectRatio(null);
    setCropRounding(0);
    setLockAspectRatio(true);
  }, [originalImage]);

  const startCroppingSession = useCallback(() => {
    if (!crop) return;
    setCropSessionStartCrop(crop);
    setIsCropping(true);
  }, [crop]);

  /**
   * Confirms the interactive crop session.
   * Calculates the final crop in original image coordinates based on the
   * interactive overlay state and the display scale.
   *
   * @param {object} currentInteractiveCrop - The {x, y, width, height} from the overlay in *display* pixels.
   * @param {number} currentScale - The scale factor between the display canvas and the *original image portion shown at the start of the session*.
   */
  const confirmCrop = useCallback(
    (currentInteractiveCrop, currentScale) => {
      if (
        !currentInteractiveCrop ||
        !cropSessionStartCrop ||
        !currentScale ||
        currentScale <= 0
      ) {
        console.error("Cannot confirm crop - missing state or invalid scale", {
          currentInteractiveCrop,
          cropSessionStartCrop,
          currentScale,
        });
        setIsCropping(false);
        setCropSessionStartCrop(null);
        return;
      }

      const deltaX_orig = currentInteractiveCrop.x / currentScale;
      const deltaY_orig = currentInteractiveCrop.y / currentScale;
      const newWidth_orig = currentInteractiveCrop.width / currentScale;
      const newHeight_orig = currentInteractiveCrop.height / currentScale;

      const finalX = cropSessionStartCrop.x + deltaX_orig;
      const finalY = cropSessionStartCrop.y + deltaY_orig;
      const finalWidth = newWidth_orig;
      const finalHeight = newHeight_orig;

      setCrop({
        x: Math.round(Math.max(0, finalX)),
        y: Math.round(Math.max(0, finalY)),
        width: Math.round(Math.max(1, finalWidth)),
        height: Math.round(Math.max(1, finalHeight)),
      });

      setIsCropping(false);
      setCropSessionStartCrop(null);
    },
    [cropSessionStartCrop]
  );

  const cancelCrop = useCallback(() => {
    setIsCropping(false);
    setCropSessionStartCrop(null);
  }, []);

  return {
    crop,
    isCropping,
    aspectRatio,
    setAspectRatio,
    cropRounding,
    setCropRounding,
    lockAspectRatio,
    setLockAspectRatio,
    startCroppingSession,
    confirmCrop,
    cancelCrop,
  };
}
</file>

<file path="src/hooks/useExportManager.js">
import { useState, useCallback, useEffect } from "react";
import { exportImage } from "../lib/exportUtils";

export function useExportManager(
  defaultFormat = "image/png",
  defaultQuality = 92
) {
  const [format, setFormat] = useState(defaultFormat);
  const [quality, setQuality] = useState(defaultQuality);
  const [lossless, setLossless] = useState(false);
  const [isExporting, setIsExporting] = useState(false);
  const [exportError, setExportError] = useState(null);

  const [enableResizing, setEnableResizing] = useState(false);
  const [targetWidth, setTargetWidth] = useState("");
  const [targetHeight, setTargetHeight] = useState("");
  const [keepAspectRatio, setKeepAspectRatio] = useState(true);

  useEffect(() => {
    if (!enableResizing) {
      setTargetWidth("");
      setTargetHeight("");
    }
  }, [enableResizing]);

  useEffect(() => {
    if (format !== "image/webp") {
      setLossless(false);
    }
  }, [format]);

  const startExport = useCallback(
    async ({
      image,
      crop,
      filter,
      adjustments,
      rounding,
      originalFilename,
    }) => {
      if (!image || !crop) {
        setExportError("Cannot export: Image or crop data missing.");
        return;
      }

      let finalExportWidth = Math.round(crop.width);
      let finalExportHeight = Math.round(crop.height);

      if (enableResizing) {
        const parsedW = parseInt(targetWidth, 10);
        const parsedH = parseInt(targetHeight, 10);
        const isValidW = parsedW > 0;
        const isValidH = parsedH > 0;

        if (isValidW || isValidH) {
          if (keepAspectRatio) {
            const cropRatio = crop.width / crop.height;
            if (isValidW && !isValidH) {
              finalExportWidth = parsedW;
              finalExportHeight = Math.round(parsedW / cropRatio);
            } else if (!isValidW && isValidH) {
              finalExportHeight = parsedH;
              finalExportWidth = Math.round(parsedH * cropRatio);
            } else {
              finalExportWidth = parsedW || finalExportWidth;
              finalExportHeight = Math.round(finalExportWidth / cropRatio);
            }
          } else {
            finalExportWidth = isValidW ? parsedW : finalExportWidth;
            finalExportHeight = isValidH ? parsedH : finalExportHeight;
          }
        }
      }
      finalExportWidth = Math.max(1, finalExportWidth);
      finalExportHeight = Math.max(1, finalExportHeight);

      setIsExporting(true);
      setExportError(null);

      const exportOptions = {
        image,
        crop,
        filter,
        adjustments,
        rounding,
        format,
        quality,
        lossless,
        originalFilename,
        outputWidth: finalExportWidth,
        outputHeight: finalExportHeight,
      };

      try {
        await exportImage(exportOptions);
      } catch (err) {
        setExportError(
          err.message || "An unknown error occurred during export."
        );
      } finally {
        setIsExporting(false);
      }
    },
    [
      format,
      quality,
      lossless,
      enableResizing,
      targetWidth,
      targetHeight,
      keepAspectRatio,
    ]
  );

  return {
    format,
    quality,
    lossless,
    isExporting,
    exportError,
    enableResizing,
    targetWidth,
    targetHeight,
    keepAspectRatio,
    setFormat,
    setQuality,
    setLossless,
    setEnableResizing,
    setTargetWidth,
    setTargetHeight,
    setKeepAspectRatio,
    startExport,
    clearExportError: () => setExportError(null),
  };
}
</file>

<file path="src/hooks/useImageLoader.js">
import { useState, useEffect, useRef } from "react";
import * as UTIF from "utif";

export function useImageLoader() {
  const [file, setFile] = useState(null);
  const [originalImage, setOriginalImage] = useState(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  const currentUrlRef = useRef(null);

  useEffect(() => {
    setError(null);
    setOriginalImage(null);
    if (currentUrlRef.current) {
      URL.revokeObjectURL(currentUrlRef.current);
      currentUrlRef.current = null;
    }
    if (!file) {
      setIsLoading(false);
      return;
    }

    setIsLoading(true);

    const isTiff =
      file.type === "image/tiff" ||
      file.name.toLowerCase().endsWith(".tif") ||
      file.name.toLowerCase().endsWith(".tiff");
    if (!isTiff) {
      const img = new Image();
      const url = URL.createObjectURL(file);
      currentUrlRef.current = url;

      img.onload = () => {
        setOriginalImage(img);
        setIsLoading(false);
      };

      img.onerror = (err) => {
        console.error("Error loading image:", err);
        setError("Failed to load the image. Please try a different file.");
        setOriginalImage(null);
        setIsLoading(false);
        URL.revokeObjectURL(url);
        currentUrlRef.current = null;
      };

      img.src = url;
    } else {
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const arrayBuffer = e.target.result;
          const ifds = UTIF.decode(arrayBuffer);
          if (!ifds || ifds.length === 0) {
            throw new Error("No image data found in TIFF file.");
          }
          UTIF.decodeImage(arrayBuffer, ifds[0]);
          const width = ifds[0].width;
          const height = ifds[0].height;
          const rgba = UTIF.toRGBA8(ifds[0]);
          if (!width || !height || !rgba) {
            throw new Error("Failed to decode TIFF pixel data.");
          }

          const canvas = document.createElement("canvas");
          canvas.width = width;
          canvas.height = height;
          const ctx = canvas.getContext("2d");
          const imageData = new ImageData(
            new Uint8ClampedArray(rgba),
            width,
            height
          );
          ctx.putImageData(imageData, 0, 0);
          setOriginalImage(canvas);
          setIsLoading(false);
        } catch (decodeError) {
          console.error("Error decoding TIFF:", decodeError);
          setError(`Failed to decode TIFF: ${decodeError.message}`);
          setOriginalImage(null);
          setIsLoading(false);
        }
      };

      reader.onerror = (err) => {
        console.error("Error reading TIFF file:", err);
        setError("Failed to read the selected TIFF file.");
        setOriginalImage(null);
        setIsLoading(false);
      };

      reader.readAsArrayBuffer(file);
    }

    return () => {
      if (currentUrlRef.current) {
        URL.revokeObjectURL(currentUrlRef.current);
        currentUrlRef.current = null;
      }
    };
  }, [file]);

  return {
    file,
    setFile,
    originalImage,
    isLoading,
    error,
  };
}
</file>

<file path="src/hooks/useInteractiveCrop.js">
import { useState, useEffect, useCallback } from "react";

const MIN_CROP_SIZE_DISPLAY = 20;
const HANDLE_SIZE = 12;

export function useInteractiveCrop({
  containerRef,
  canvasWidth,
  canvasHeight,
  aspectRatio,
  lockAspectRatio,
  isCropping,
  cropRounding,
  disabled = false,
}) {
  const [interactiveCrop, setInteractiveCrop] = useState(null);
  const [isDragging, setIsDragging] = useState(false);
  const [isResizing, setIsResizing] = useState(false);
  const [startPos, setStartPos] = useState({ x: 0, y: 0 });
  const [startCropData, setStartCropData] = useState(null);

  useEffect(() => {
    if (isCropping && !disabled) {
      if (canvasWidth <= 0 || canvasHeight <= 0) {
        console.warn(
          "Cannot initialize interactive crop: Canvas size unknown or invalid."
        );
        setInteractiveCrop(null);
        onCropChange?.(null);
        return;
      }

      let initialWidth = canvasWidth;
      let initialHeight = canvasHeight;
      let initialX = 0;
      let initialY = 0;

      if (aspectRatio) {
        const displayRatio = canvasWidth / canvasHeight;
        if (aspectRatio > displayRatio) {
          initialHeight = initialWidth / aspectRatio;
        } else {
          initialWidth = initialHeight * aspectRatio;
        }
        initialX = (canvasWidth - initialWidth) / 2;
        initialY = (canvasHeight - initialHeight) / 2;
      }

      const initialCropData = {
        x: Math.round(initialX),
        y: Math.round(initialY),
        width: Math.round(Math.max(MIN_CROP_SIZE_DISPLAY, initialWidth)),
        height: Math.round(Math.max(MIN_CROP_SIZE_DISPLAY, initialHeight)),
      };
      setInteractiveCrop(initialCropData);
    } else {
      setInteractiveCrop(null);
      setIsDragging(false);
      setIsResizing(false);
      setStartPos({ x: 0, y: 0 });
      setStartCropData(null);
    }
  }, [isCropping, aspectRatio, canvasWidth, canvasHeight, disabled]);

  const getMousePos = useCallback(
    (e) => {
      if (!containerRef.current) return { x: 0, y: 0 };
      const rect = containerRef.current.getBoundingClientRect();
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      return { x: clientX - rect.left, y: clientY - rect.top };
    },
    [containerRef]
  );

  const handleInteractionStart = useCallback(
    (e) => {
      if (disabled || !isCropping || !interactiveCrop) return;
      const mousePos = getMousePos(e);
      const handleX =
        interactiveCrop.x + interactiveCrop.width - HANDLE_SIZE / 2;
      const handleY =
        interactiveCrop.y + interactiveCrop.height - HANDLE_SIZE / 2;
      const handleArea = {
        x: handleX - HANDLE_SIZE,
        y: handleY - HANDLE_SIZE,
        width: HANDLE_SIZE * 2,
        height: HANDLE_SIZE * 2,
      };
      let interactionType = null;
      if (
        mousePos.x >= handleArea.x &&
        mousePos.x <= handleArea.x + handleArea.width &&
        mousePos.y >= handleArea.y &&
        mousePos.y <= handleArea.y + handleArea.height
      ) {
        interactionType = "resize";
      } else if (
        mousePos.x >= interactiveCrop.x &&
        mousePos.x <= interactiveCrop.x + interactiveCrop.width &&
        mousePos.y >= interactiveCrop.y &&
        mousePos.y <= interactiveCrop.y + interactiveCrop.height
      ) {
        interactionType = "drag";
      }

      if (interactionType) {
        e.preventDefault();
        e.stopPropagation();
        setIsDragging(interactionType === "drag");
        setIsResizing(interactionType === "resize");
        setStartPos(mousePos);
        setStartCropData(interactiveCrop);
      }
    },
    [disabled, isCropping, interactiveCrop, getMousePos]
  );

  const handleInteractionMove = useCallback(
    (e) => {
      if (disabled || (!isDragging && !isResizing) || !startCropData) return;

      e.preventDefault();
      e.stopPropagation();

      const mousePos = getMousePos(e);
      const dx = mousePos.x - startPos.x;
      const dy = mousePos.y - startPos.y;

      let newCropData = { ...startCropData };
      const bounds = { width: canvasWidth || 0, height: canvasHeight || 0 };

      if (bounds.width <= 0 || bounds.height <= 0) return;

      if (isDragging) {
        newCropData.x = startCropData.x + dx;
        newCropData.y = startCropData.y + dy;
        newCropData.x = Math.max(
          0,
          Math.min(newCropData.x, bounds.width - newCropData.width)
        );
        newCropData.y = Math.max(
          0,
          Math.min(newCropData.y, bounds.height - newCropData.height)
        );
      } else if (isResizing) {
        let newWidth = startCropData.width + dx;
        let newHeight = startCropData.height + dy;
        newWidth = Math.max(MIN_CROP_SIZE_DISPLAY, newWidth);
        newHeight = Math.max(MIN_CROP_SIZE_DISPLAY, newHeight);
        newWidth = Math.min(newWidth, bounds.width - newCropData.x);
        newHeight = Math.min(newHeight, bounds.height - newCropData.y);
        if (lockAspectRatio && aspectRatio && aspectRatio > 0) {
          let adjustedHeight = newWidth / aspectRatio;
          if (newCropData.y + adjustedHeight > bounds.height) {
            adjustedHeight = bounds.height - newCropData.y;
            newWidth = adjustedHeight * aspectRatio;
          }
          if (newWidth < MIN_CROP_SIZE_DISPLAY) {
            newWidth = MIN_CROP_SIZE_DISPLAY;
            adjustedHeight = newWidth / aspectRatio;
            if (newCropData.y + adjustedHeight > bounds.height) {
              adjustedHeight = bounds.height - newCropData.y;
            }
          }
          if (adjustedHeight < MIN_CROP_SIZE_DISPLAY) {
            adjustedHeight = MIN_CROP_SIZE_DISPLAY;
            newWidth = adjustedHeight * aspectRatio;
            if (newCropData.x + newWidth > bounds.width) {
              newWidth = bounds.width - newCropData.x;
            }
          }
          newHeight = adjustedHeight;
        }
        newCropData.width = Math.max(
          MIN_CROP_SIZE_DISPLAY,
          Math.min(newWidth, bounds.width - newCropData.x)
        );
        newCropData.height = Math.max(
          MIN_CROP_SIZE_DISPLAY,
          Math.min(newHeight, bounds.height - newCropData.y)
        );
      }

      const finalCrop = {
        x: Math.round(newCropData.x),
        y: Math.round(newCropData.y),
        width: Math.round(newCropData.width),
        height: Math.round(newCropData.height),
      };
      setInteractiveCrop(finalCrop);
    },
    [
      disabled,
      isDragging,
      isResizing,
      startCropData,
      startPos,
      canvasWidth,
      canvasHeight,
      lockAspectRatio,
      aspectRatio,
      getMousePos,
    ]
  );

  const handleInteractionEnd = useCallback(
    (e) => {
      if (disabled) return;
      if (isDragging || isResizing) {
        e.preventDefault();
        e.stopPropagation();
        setIsDragging(false);
        setIsResizing(false);
        setStartPos({ x: 0, y: 0 });
        setStartCropData(null);
      }
    },
    [disabled, isDragging, isResizing]
  );

  useEffect(() => {
    if (disabled || (!isDragging && !isResizing)) {
      return;
    }
    window.addEventListener("mousemove", handleInteractionMove);
    window.addEventListener("mouseup", handleInteractionEnd);
    window.addEventListener("touchmove", handleInteractionMove, {
      passive: false,
    });
    window.addEventListener("touchend", handleInteractionEnd);
    window.addEventListener("mouseleave", handleInteractionEnd);

    return () => {
      window.removeEventListener("mousemove", handleInteractionMove);
      window.removeEventListener("mouseup", handleInteractionEnd);
      window.removeEventListener("touchmove", handleInteractionMove);
      window.removeEventListener("touchend", handleInteractionEnd);
      window.removeEventListener("mouseleave", handleInteractionEnd);
    };
  }, [
    disabled,
    isDragging,
    isResizing,
    handleInteractionMove,
    handleInteractionEnd,
  ]);

  const overlayStyle =
    interactiveCrop && isCropping && !disabled
      ? {
          position: "absolute",
          border: "2px solid rgb(59, 130, 246)",
          cursor: isDragging ? "grabbing" : isResizing ? "nwse-resize" : "grab",
          left: `${interactiveCrop.x}px`,
          top: `${interactiveCrop.y}px`,
          width: `${interactiveCrop.width}px`,
          height: `${interactiveCrop.height}px`,
          pointerEvents: "auto",
          boxShadow: "0 0 0 9999px rgba(0, 0, 0, 0.5)",
          boxSizing: "border-box",
          borderRadius: `${cropRounding || 0}%`,
          touchAction: "none",
        }
      : { display: "none" };

  const handleStyle =
    interactiveCrop && isCropping && !disabled
      ? {
          position: "absolute",
          width: `${HANDLE_SIZE}px`,
          height: `${HANDLE_SIZE}px`,
          background: "rgb(59, 130, 246)",
          right: `-${HANDLE_SIZE / 2}px`,
          bottom: `-${HANDLE_SIZE / 2}px`,
          cursor: "nwse-resize",
          borderRadius: "2px",
          border: "1px solid white",
          boxSizing: "border-box",
          pointerEvents: "auto",
          touchAction: "none",
        }
      : { display: "none" };

  const overlayProps = {
    style: overlayStyle,
    onMouseDown: handleInteractionStart,
    onTouchStart: handleInteractionStart,
    onClick: (e) => e.stopPropagation(),
  };

  const handleProps = {
    style: handleStyle,
    onMouseDown: handleInteractionStart,
    onTouchStart: handleInteractionStart,
    onClick: (e) => e.stopPropagation(),
  };

  return {
    interactiveCrop,
    overlayProps,
    handleProps,
    isInteracting: isDragging || isResizing,
  };
}
</file>

<file path="src/lib/EffectEngine.js">
export const filterMap = {
  None: "",
  Grayscale: "grayscale(1)",
  Vintage: "sepia(0.5) contrast(1.2) brightness(0.9)",
  Vibrant: "saturate(1.5)",
  "Soft Focus": "blur(2px)",
  Noir: "grayscale(1) contrast(1.5)",
  Sepia: "sepia(1)",
  Invert: "invert(1)",
  Polaroid: "contrast(0.9) brightness(1.1)",
};

export const adjustmentMap = {
  brightness: (value) => `brightness(${value}%)`,
  contrast: (value) => `contrast(${value}%)`,
  saturation: (value) => `saturate(${value}%)`,
  hue: (value) => `hue-rotate(${value}deg)`,
};

const applySketchEffect = (ctx, image, canvas) => {
  const width = canvas.width;
  const height = canvas.height;
  ctx.drawImage(image, 0, 0, width, height);
  const imageData = ctx.getImageData(0, 0, width, height);
  const { data } = imageData;
  const grayscale = new Uint8ClampedArray(width * height);
  for (let i = 0; i < data.length; i += 4) {
    grayscale[i / 4] =
      0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
  }
  const sobelX = [-1, 0, 1, -2, 0, 2, -1, 0, 1];
  const sobelY = [-1, -2, -1, 0, 0, 0, 1, 2, 1];
  const output = new Uint8ClampedArray(data.length);
  for (let y = 1; y < height - 1; y++) {
    for (let x = 1; x < width - 1; x++) {
      let gx = 0;
      let gy = 0;
      for (let ky = -1; ky <= 1; ky++) {
        for (let kx = -1; kx <= 1; kx++) {
          const px = x + kx;
          const py = y + ky;
          const idx = py * width + px;
          const weightX = sobelX[(ky + 1) * 3 + (kx + 1)];
          const weightY = sobelY[(ky + 1) * 3 + (kx + 1)];
          gx += weightX * grayscale[idx];
          gy += weightY * grayscale[idx];
        }
      }
      const magnitude = Math.sqrt(gx * gx + gy * gy);
      const intensity = 255 - Math.min(255, magnitude);
      const outIdx = (y * width + x) * 4;
      output[outIdx] = output[outIdx + 1] = output[outIdx + 2] = intensity;
      output[outIdx + 3] = 255;
    }
  }
  const result = new ImageData(output, width, height);
  ctx.putImageData(result, 0, 0);
};

function _calculateDrawRects(image, crop, targetWidth, targetHeight) {
  let sx = 0,
    sy = 0,
    sWidth = image.width,
    sHeight = image.height;
  let dx = 0,
    dy = 0,
    dWidth = targetWidth,
    dHeight = targetHeight;

  if (crop && crop.width > 0 && crop.height > 0) {
    sx = Math.max(0, crop.x);
    sy = Math.max(0, crop.y);
    sWidth = Math.min(crop.width, image.width - sx);
    sHeight = Math.min(crop.height, image.height - sy);

    if (sWidth <= 0 || sHeight <= 0) {
      sx = 0;
      sy = 0;
      sWidth = image.width;
      sHeight = image.height;
    }
    dx = 0;
    dy = 0;
    dWidth = targetWidth;
    dHeight = targetHeight;
  } else {
    sx = 0;
    sy = 0;
    sWidth = image.width;
    sHeight = image.height;
    dx = 0;
    dy = 0;
    dWidth = targetWidth;
    dHeight = targetHeight;
  }
  return { sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight };
}

function _applyRoundingClip(ctx, x, y, width, height, radiusPercent) {
  if (!radiusPercent || radiusPercent <= 0) return false;
  const cornerRadius = Math.min(width, height) * (radiusPercent / 100.0);
  if (cornerRadius <= 0) return false;

  ctx.save();
  ctx.beginPath();
  ctx.moveTo(x + cornerRadius, y);
  ctx.arcTo(x + width, y, x + width, y + height, cornerRadius);
  ctx.arcTo(x + width, y + height, x, y + height, cornerRadius);
  ctx.arcTo(x, y + height, x, y, cornerRadius);
  ctx.arcTo(x, y, x + width, y, cornerRadius);
  ctx.closePath();
  ctx.clip();
  return true;
}

export const applySharpness = (ctx, canvas, sharpnessValue) => {
  if (sharpnessValue >= 0) {
    const weight = sharpnessValue / 100;
    const kCenter = 1 + 4 * weight;
    const width = canvas.width;
    const height = canvas.height;
    const imageData = ctx.getImageData(0, 0, width, height);
    const data = imageData.data;
    const output = new Uint8ClampedArray(data.length);
    const w4 = width * 4;

    for (let y = 1, rowOffset = w4; y < height - 1; y++, rowOffset += w4) {
      for (let x = 1; x < width - 1; x++) {
        const i = rowOffset + x * 4;
        const i_tl = i - w4 - 4;
        const i_tc = i - w4;
        const i_tr = i - w4 + 4;
        const i_ml = i - 4;
        const i_m = i;
        const i_mr = i + 4;
        const i_bl = i + w4 - 4;
        const i_bc = i + w4;
        const i_br = i + w4 + 4;

        let r =
          0 * data[i_tl] +
          -weight * data[i_tc] +
          0 * data[i_tr] +
          -weight * data[i_ml] +
          kCenter * data[i_m] +
          -weight * data[i_mr] +
          0 * data[i_bl] +
          -weight * data[i_bc] +
          0 * data[i_br];
        let g =
          0 * data[i_tl + 1] +
          -weight * data[i_tc + 1] +
          0 * data[i_tr + 1] +
          -weight * data[i_ml + 1] +
          kCenter * data[i_m + 1] +
          -weight * data[i_mr + 1] +
          0 * data[i_bl + 1] +
          -weight * data[i_bc + 1] +
          0 * data[i_br + 1];
        let b =
          0 * data[i_tl + 2] +
          -weight * data[i_tc + 2] +
          0 * data[i_tr + 2] +
          -weight * data[i_ml + 2] +
          kCenter * data[i_m + 2] +
          -weight * data[i_mr + 2] +
          0 * data[i_bl + 2] +
          -weight * data[i_bc + 2] +
          0 * data[i_br + 2];

        output[i] = Math.min(255, Math.max(0, r));
        output[i + 1] = Math.min(255, Math.max(0, g));
        output[i + 2] = Math.min(255, Math.max(0, b));
        output[i + 3] = data[i + 3];
      }
    }
    ctx.putImageData(new ImageData(output, width, height), 0, 0);
  } else {
    const blurRadius = Math.abs(sharpnessValue) * 0.025;
    const tempCanvas = document.createElement("canvas");
    tempCanvas.width = canvas.width;
    tempCanvas.height = canvas.height;
    const tempCtx = tempCanvas.getContext("2d");
    tempCtx.drawImage(canvas, 0, 0);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.filter = `blur(${blurRadius}px)`;
    ctx.drawImage(tempCanvas, 0, 0);
    ctx.filter = "none";
  }
};

const applyTemperatureAndTint = (ctx, canvas, temperature, tint) => {
  const width = canvas.width;
  const height = canvas.height;
  const imageData = ctx.getImageData(0, 0, width, height);
  const data = imageData.data;
  const t = temperature;
  const ti = tint;

  for (let i = 0, len = data.length; i < len; i += 4) {
    let r = data[i] + t;
    data[i] = r < 0 ? 0 : r > 255 ? 255 : r;

    let g = data[i + 1] + ti;
    data[i + 1] = g < 0 ? 0 : g > 255 ? 255 : g;

    let b = data[i + 2] - t;
    data[i + 2] = b < 0 ? 0 : b > 255 ? 255 : b;
  }
  ctx.putImageData(imageData, 0, 0);
};

export const applyAllEffects = (
  ctx,
  image,
  canvas,
  filter,
  adjustments,
  crop = null,
  cropRounding = 0
) => {
  const targetWidth = canvas.width;
  const targetHeight = canvas.height;
  ctx.clearRect(0, 0, targetWidth, targetHeight);

  const { sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight } =
    _calculateDrawRects(image, crop, targetWidth, targetHeight);

  if (sWidth <= 0 || sHeight <= 0 || dWidth <= 0 || dHeight <= 0) {
    return;
  }

  const clipped = _applyRoundingClip(
    ctx,
    dx,
    dy,
    dWidth,
    dHeight,
    cropRounding
  );
  ctx.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);
  if (clipped) {
    ctx.restore();
  }

  const tempEffectCanvas = document.createElement("canvas");
  tempEffectCanvas.width = targetWidth;
  tempEffectCanvas.height = targetHeight;
  const tempEffectCtx = tempEffectCanvas.getContext("2d");
  tempEffectCtx.drawImage(canvas, 0, 0);

  ctx.clearRect(0, 0, targetWidth, targetHeight);

  if (filter === "Sketch") {
    applySketchEffect(tempEffectCtx, tempEffectCanvas, tempEffectCanvas);
    ctx.drawImage(tempEffectCanvas, 0, 0);
  } else {
    const cssFilters = [];
    if (filterMap[filter]) {
      cssFilters.push(filterMap[filter]);
    }
    if (adjustments.brightness !== undefined) {
      cssFilters.push(adjustmentMap.brightness(adjustments.brightness));
    }
    if (adjustments.contrast !== undefined) {
      cssFilters.push(adjustmentMap.contrast(adjustments.contrast));
    }
    if (adjustments.saturation !== undefined) {
      cssFilters.push(adjustmentMap.saturation(adjustments.saturation));
    }
    if (adjustments.hue !== undefined) {
      cssFilters.push(adjustmentMap.hue(adjustments.hue));
    }

    if (cssFilters.length > 0) {
      tempEffectCtx.filter = cssFilters.join(" ");
      tempEffectCtx.drawImage(tempEffectCanvas, 0, 0);
      tempEffectCtx.filter = "none";
    }
    ctx.drawImage(tempEffectCanvas, 0, 0);
  }

  if (adjustments.sharpness !== undefined && adjustments.sharpness !== 0) {
    applySharpness(ctx, canvas, adjustments.sharpness);
  }
  if (
    (adjustments.temperature && adjustments.temperature !== 0) ||
    (adjustments.tint && adjustments.tint !== 0)
  ) {
    applyTemperatureAndTint(
      ctx,
      canvas,
      adjustments.temperature || 0,
      adjustments.tint || 0
    );
  }
};
</file>

<file path="src/lib/exportUtils.js">
import * as UTIF from "utif";
import { applyAllEffects } from "./EffectEngine";

/**
 * Exports the processed image based on provided options.
 * @param {object} options
 * @param {HTMLImageElement} options.image - The original image element.
 * @param {object} options.crop - The crop parameters {x, y, width, height}.
 * @param {string} options.filter - The name of the selected filter.
 * @param {object} options.adjustments - Object with adjustment values.
 * @param {number} options.rounding - Crop rounding percentage (0-50).
 * @param {string} options.format - The desired mime type (e.g., 'image/png').
 * @param {number} options.quality - Quality setting (0-100).
 * @param {boolean} options.lossless - Lossless setting for WebP.
 * @param {string} options.originalFilename - The original filename for naming the export.
 * @param {number} options.outputWidth - The desired output width in pixels.
 * @param {number} options.outputHeight - The desired output height in pixels.
 * @returns {Promise<void>} A promise that resolves when the download is initiated or rejects on error.
 */
export async function exportImage({
  image,
  crop,
  filter,
  adjustments,
  rounding,
  format,
  quality,
  lossless,
  originalFilename = "image.png",
  outputWidth,
  outputHeight,
}) {
  if (!image || !crop || crop.width <= 0 || crop.height <= 0) {
    console.error("Export failed: Invalid image or crop data.", {
      image,
      crop,
    });
    throw new Error("Cannot export: Missing image or invalid crop dimensions.");
  }

  if (!outputWidth || !outputHeight || outputWidth <= 0 || outputHeight <= 0) {
    throw new Error("Cannot export: Invalid output dimensions calculated.");
  }

  const exportCanvas = document.createElement("canvas");
  const exportCtx = exportCanvas.getContext("2d");

  exportCanvas.width = Math.round(outputWidth);
  exportCanvas.height = Math.round(outputHeight);

  try {
    applyAllEffects(
      exportCtx,
      image,
      exportCanvas,
      filter,
      adjustments,
      crop,
      rounding
    );
  } catch (error) {
    console.error("Error applying effects during export:", error);
    throw new Error("Failed to apply image effects during export.");
  }

  const mimeType = format;
  let exportQualityArg = undefined;
  if (mimeType === "image/jpeg" || (mimeType === "image/webp" && !lossless)) {
    exportQualityArg = Math.min(1, Math.max(0, quality / 100));
  }

  let blob;
  if (mimeType === "image/tiff") {
    try {
      const imageData = exportCtx.getImageData(
        0,
        0,
        exportCanvas.width,
        exportCanvas.height
      );
      const rgbaBuffer = imageData.data.buffer;
      const tiffArrayBuffer = UTIF.encodeImage(
        rgbaBuffer,
        exportCanvas.width,
        exportCanvas.height
      );
      blob = new Blob([tiffArrayBuffer], { type: "image/tiff" });
    } catch (encodeError) {
      throw new Error(`Failed to encode TIFF: ${encodeError.message}`);
    }
  } else {
    blob = await new Promise((resolve, reject) => {
      exportCanvas.toBlob(
        (b) => {
          if (b) {
            resolve(b);
          } else {
            reject(
              new Error("Canvas toBlob returned null. Check format/quality.")
            );
          }
        },
        mimeType,
        exportQualityArg
      );
    });
  }

  if (!blob) {
    throw new Error("Failed to create image blob.");
  }

  try {
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;

    const baseName =
      originalFilename.split(".").slice(0, -1).join(".") || "image";
    const formatSuffix = mimeType.split("/")[1] || "bin";
    const filename = `${baseName}_edited.${formatSuffix}`;
    a.download = filename;

    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  } catch (downloadError) {
    console.error("Error triggering download:", downloadError);
  }
}
</file>

<file path="src/pages/about.astro">
---
import Layout from '../layouts/Layout.astro';
---
<Layout title="About imgStyler">
  <div class="p-6 max-w-6xl  mx-auto">
    <h1 class="text-3xl font-bold mb-4">About imgStyler</h1>
    <p class="mb-4">
      imgStyler was created to provide a simple, fast, and free way to perform common image editing tasks
      directly in the web browser without needing to install software or upload your images to a server.
    </p>
    <p class="mb-4">
      Our goal is to offer essential tools like cropping, filtering, and color adjustments in an intuitive
      interface. We prioritize user privacy by processing images entirely on the client-side using
      JavaScript and the Canvas API.
    </p>
    <p class="mb-4">
      imgStyler is developed and maintained by <a
        href="https://dev4pgh.com"
        target="_blank"
        rel="noopener noreferrer"
        class="text-blue-600 dark:text-blue-400 hover:underline"
      >Dev4PGH LLC</a>.
    </p>
  </div>
</Layout>
</file>

<file path="src/pages/contact.astro">
---
import Layout from '../layouts/Layout.astro';
const contactEmail = "dev4pgh@gmail.com";
---
<Layout title="Contact Us - imgStyler" description="Get in touch with imgStyler for support or feedback.">
  <div class="p-6 max-w-6xl mx-auto">
    <h1 class="text-3xl font-bold mb-4">Contact Us</h1>
    <p class="mb-6">
      Have questions, feedback, or need support? We'd love to hear from you!
    </p>
    <p>
      The best way to reach us regarding imgStyler is via email:
    </p>
    <a
      href={`mailto:${contactEmail}`}
      class="inline-block mt-2 text-lg text-blue-600 dark:text-blue-400 hover:underline font-semibold break-all"
    >
      {contactEmail}
    </a>
    <p class="mt-8">
        imgStyler is developed by Dev4PGH LLC. You can learn more about the developer at their website:
        <a
          href="https://dev4pgh.com"
          target="_blank"
          rel="noopener noreferrer"
          class="block mt-1 text-lg font-bold text-blue-600 dark:text-blue-400 hover:underline"
        >
          dev4pgh.com
        </a>
      </p>
    </div>
</Layout>
</file>

<file path="src/pages/features.astro">
---
import Layout from '../layouts/Layout.astro';
---
<Layout title="Features - imgStyler" description="Explore the features of imgStyler including cropping, adjustments, filters, privacy, and export options.">
  <div class="p-6 max-w-6xl mx-auto">
    <h1 class="text-3xl font-bold mb-6 border-b pb-2 dark:border-gray-700">imgStyler Features</h1>

    <section class="mb-8">
      <h2 class="text-2xl font-semibold mb-2">Cropping & Resizing</h2>
      <p class="mb-2">
        Take full control of your image composition. Crop interactively using a freeform selection box, enter custom aspect ratios, or select from convenient presets designed for social media platforms like Instagram, Twitter, Facebook, and more.
      </p>
      <ul class="list-disc list-inside space-y-1 ml-4">
        <li>Freeform & Custom Ratio Cropping</li>
        <li>Social Media Presets (1:1, 4:5, 16:9, etc.)</li>
        <li>Lock Aspect Ratio Option</li>
        <li>Apply Corner Rounding (set it to 50% for a circle)</li>
        <li>Resize Output Dimensions During Export</li>
      </ul>
    </section>

    <section class="mb-8">
      <h2 class="text-2xl font-semibold mb-2">Fine-Tune Adjustments</h2>
      <p class="mb-2">
        Go beyond basic edits with a comprehensive set of adjustment sliders. Perfect the look and feel of your images with granular control.
      </p>
      <ul class="list-disc list-inside space-y-1 ml-4">
        <li>Brightness</li>
        <li>Contrast</li>
        <li>Saturation</li>
        <li>Hue Rotation</li>
        <li>Sharpness</li>
        <li>Color Temperature (Warm/Cool)</li>
        <li>Tint (Green/Magenta)</li>
      </ul>
    </section>

    <section class="mb-8">
      <h2 class="text-2xl font-semibold mb-2">Creative Filters</h2>
      <p class="mb-2">
        Apply artistic effects instantly with a selection of built-in filters. Change the mood of your photo with a single click.
      </p>
      <ul class="list-disc list-inside space-y-1 ml-4">
        <li>Grayscale, Vintage, Vibrant</li>
        <li>Soft Focus, Noir, Sepia</li>
        <li>Invert, Polaroid, Sketch</li>
      </ul>
    </section>

    <section class="mb-8">
      <h2 class="text-2xl font-semibold mb-2">Flexible Export Options</h2>
      <p class="mb-2">
        Save your work in the format that best suits your needs. Control quality and file size for web formats. Use imgStyler as a simple image converter.
      </p>
      <ul class="list-disc list-inside space-y-1 ml-4">
        <li><strong>PNG:</strong> Lossless quality.</li>
        <li><strong>JPEG:</strong> Adjustable quality slider for smaller file sizes.</li>
        <li><strong>WebP:</strong> Choose between lossless or adjustable quality (often best balance).</li>
        <li><strong>TIFF:</strong> Lossless format suitable for further editing.</li>
        <li>Optionally resize image dimensions upon export.</li>
      </ul>
    </section>

    <section>
      <h2 class="text-2xl font-semibold mb-2">Completely Local & Private</h2>
      <p>
        Your privacy is paramount. All image processing happens directly within your web browser using JavaScript. <strong>No image data is ever uploaded to any server.</strong> Your files stay securely on your own computer.
      </p>
    </section>
  </div>
</Layout>
</file>

<file path="src/styles/global.css">
@import "tailwindcss";

@custom-variant dark (&:where(.dark, .dark *));
</file>

<file path=".env.example">
UMAMI_SCRIPT_URL="https://analytics.mysite.com/script.js"
UMAMI_WEBSITE_ID="XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX"
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2025 Dev4PGH LLC

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="src/layouts/Layout.astro">
---
import Header from "../components/ui/Header"
import '../styles/global.css';

export interface Props {
	title: string;
	description?: string;
	image?: string;
}
const { title = 'imgStyler', description = 'Free online image editor to crop, resize, apply filters, adjust brightness, contrast, saturation, and export images.', image = "/imgStyler_preview.png" } = Astro.props;

const canonicalUrl = Astro.url.href;
const absoluteImageUrl = new URL(image, Astro.url.origin).href;
const imageAlt = `Preview image for imgStyler`;

const darkModeScript = `
	(function() {
		const storedPreference = localStorage.getItem('isDarkMode');
		const isDarkMode = storedPreference ? JSON.parse(storedPreference) : true;
		document.documentElement.classList.toggle('dark', isDarkMode);
	})();)
`;

const umamiScriptUrl = import.meta.env.UMAMI_SCRIPT_URL;
const umamiWebsiteId = import.meta.env.UMAMI_WEBSITE_ID;
const enableAnalytics = umamiScriptUrl && umamiWebsiteId;
---
<!doctype html>
<html lang="en" class="dark">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<meta name="description" content={description} />
		<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
		<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
		<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
		<link rel="sitemap" href="/sitemap-index.xml" />
		<meta name="generator" content={Astro.generator} />

		<title>{title}</title>

		<meta property="og:type" content="website" />
		<meta property="og:title" content={title} />
		<meta property="og:description" content={description} />
		<meta property="og:site_name" content="imgStyler" />
		<meta property="og:url" content={canonicalUrl} />
		<meta property="og:image" content={absoluteImageUrl} />
		<meta property="og:image:alt" content={imageAlt} />
		
		<meta name="twitter:card" content="summary_large_image" />
		<meta name="twitter:title" content={title} />
		<meta name="twitter:description" content={description} />
		<meta name="twitter:url" content={canonicalUrl} />
		<meta name="twitter:image" content={absoluteImageUrl} />
		<meta name="twitter:image:alt" content={imageAlt} />
		<meta name="twitter:creator" content="@Dev4PGH">

		<script is:inline define:vars={{ darkModeScript }} dangerouslySetInnerHTML={{ __html: darkModeScript }} />
		{enableAnalytics && (
			<script defer src={umamiScriptUrl} data-website-id={umamiWebsiteId}></script>
		)}
	</head>
	<body class="bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-gray-100 min-h-screen">
		<Header client:idle />
		<main>
			<slot />
		</main>
		<footer class="static-footer p-6 text-center mt-12 text-sm text-gray-600 dark:text-gray-400 border-t border-gray-200 dark:border-gray-700">
			<nav class="space-x-4 md:space-x-6 mb-4">
				<a href="/" class="hover:underline dark:text-gray-300 text-gray-700">Home</a>
				<a href="/features" class="hover:underline dark:text-gray-300 text-gray-700">Features</a>
				<a href="/about" class="hover:underline dark:text-gray-300 text-gray-700">About</a>
				<a href="/contact" class="hover:underline dark:text-gray-300 text-gray-700">Contact</a>
				<a
					href="https://github.com/dev4pgh/imgStyler-astro"
					target="_blank"
					rel="noopener noreferrer"
					class="hover:underline dark:text-gray-300 text-gray-700"
				>
					GitHub
				</a>
			</nav>
			<p class="mb-4">&copy; {new Date().getFullYear()} Dev4PGH. All rights reserved.</p>
			<p class="text-sm">
				Developed by <a
					href="https://dev4pgh.com"
					target="_blank"
					rel="noopener noreferrer"
					class="underline hover:text-gray-900 dark:hover:text-gray-100"
				>Dev4PGH LLC</a>.
			</p>
		</footer>
	</body>
</html>
</file>

<file path="src/pages/index.astro">
---
import Layout from '../layouts/Layout.astro';
import InteractiveImage from '../components/InteractiveImage.jsx';

const schema = {
  "@context": "https://schema.org",
  "@type": "SoftwareApplication",
  "name": "imgStyler",
  "applicationCategory": "MultimediaApplication",
  "applicationSubCategory": "ImageEditor",
  "operatingSystem": "Any (Web Browser)",
  "offers": {
    "@type": "Offer",
    "price": "0",
    "priceCurrency": "USD"
  },
  "description": "A free, private, browser-based online image editor for cropping, resizing, filtering, and adjusting images.",
  "url": Astro.url.href,
  "screenshot": new URL('/imgStyler_preview.png', Astro.url.origin).href
};
---
<Layout title="imgStyler - Online Image Editor & Styler">
  <script type="application/ld+json" set:html={JSON.stringify(schema)} />
  <div class="p-6">
    <InteractiveImage client:load />
  </div>
  <div class="px-4">
    <div class="mx-auto mt-8 p-6 bg-white dark:bg-gray-800 rounded-lg shadow border border-gray-200 dark:border-gray-700 space-y-6 max-w-6xl">
      <div class="text-center">
        <h2 class="text-4xl font-extrabold text-gray-900 dark:text-gray-100">imgStyler</h2>
        <p class="mt-2 text-lg text-gray-700 dark:text-gray-300">A Simple, Privacy-Friendly Image Editor. No login required!</p>
      </div>
      <div>
        <h3 class="text-2xl font-semibold text-gray-800 dark:text-gray-200">
          Style with <strong class="text-blue-500 dark:text-blue-400">Filters & Adjustments</strong>
        </h3>
        <p class="text-gray-700 dark:text-gray-300 mt-1">
          Enhance your images quickly with creative <strong class="text-blue-500 dark:text-blue-400">filters</strong> (like Vintage or Sketch) and fine-tune details using <strong class="text-blue-500 dark:text-blue-400">adjustments</strong> for brightness, contrast, saturation, sharpness, and color tuning.
        </p>
      </div>
      <div>
        <h3 class="text-2xl font-semibold text-gray-800 dark:text-gray-200">
          Completely <strong class="text-blue-500 dark:text-blue-400">Local & Private</strong>
        </h3>
        <p class="text-gray-700 dark:text-gray-300 mt-1">
          All editing happens right in your browser—<em>no files are uploaded</em>. Your images remain completely private.
        </p>
      </div>
      <div>
        <h3 class="text-2xl font-semibold text-gray-800 dark:text-gray-200">
          <strong class="text-blue-500 dark:text-blue-400">Export or Convert</strong> Easily
        </h3>
        <p class="text-gray-700 dark:text-gray-300 mt-1">
          Convert your images between formats like <strong class="text-blue-500 dark:text-blue-400">PNG, JPEG, WebP, and TIFF</strong>. Just load an image, select your desired format (adjust quality or resize if needed), and click the save button.
        </p>
      </div>
    </div>
  </div>
</Layout>
</file>

<file path=".gitignore">
# build output
dist/

# generated types
.astro/

# dependencies
node_modules/

# logs
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*

# environment variables
.env
.env.production

# macOS-specific files
.DS_Store

# jetbrains setting folder
.idea/

.env
</file>

<file path="astro.config.mjs">
// @ts-check
import { defineConfig } from "astro/config";

import react from "@astrojs/react";

import tailwindcss from "@tailwindcss/vite";

import sitemap from "@astrojs/sitemap";

// https://astro.build/config
export default defineConfig({
  site: "https://imgstyler.app",
  integrations: [react(), sitemap()],
  vite: {
    plugins: [tailwindcss()],
  },
  output: "static",
});
</file>

<file path="package.json">
{
  "name": "imgstyler-astro",
  "type": "module",
  "version": "0.0.1",
  "scripts": {
    "dev": "astro dev",
    "build": "astro build",
    "preview": "astro preview",
    "astro": "astro"
  },
  "dependencies": {
    "@astrojs/react": "^4.2.3",
    "@astrojs/sitemap": "^3.3.0",
    "@tailwindcss/vite": "^4.1.3",
    "@types/react": "^19.1.0",
    "@types/react-dom": "^19.1.1",
    "astro": "^5.6.1",
    "react": "^19.1.0",
    "react-dom": "^19.1.0",
    "tailwindcss": "^4.1.3",
    "utif": "^3.1.0"
  }
}
</file>

<file path="README.md">
# imgStyler

**[Live Demo](https://imgstyler.app)**

**Simple, Fast, Privacy-Friendly Image Editor for Web**

imgStyler is a minimalistic, intuitive, and entirely browser-based image editor designed to quickly prepare your images for online use. Built specifically to simplify common tasks—cropping, applying filters, adjustments, and exporting—it lets you rapidly enhance and optimize images without complex software or uploads.

## Key Features

### 🚀 Simple, Intuitive Interface
- Quickly crop images using freeform selection or handy social media presets.
- Apply adjustments like brightness, contrast, saturation, hue, sharpness, and more.
- Instantly preview and select from built-in artistic filters such as Vintage, Grayscale, Noir, Sepia, and Sketch.

### 🎯 Optimized for Online Use
- Export in popular formats (PNG, JPEG, WebP, TIFF).
- Customize image quality, resize dimensions, and choose lossless or lossy compression.

### 🔒 Completely Local & Private
- All image processing happens in your web browser using JavaScript.
- No data or images are ever uploaded to a server—your files stay private.

## Getting Started

### Installation

Clone this repository:
```sh
git clone https://github.com/dev4pgh/imgstyler-astro.git
cd imgstyler
npm install
npm run dev
```

Open your browser and navigate to the local URL provided.

### Optional: Setting Up Analytics (Umami)

This project includes integration for [Umami](https://umami.is/), a privacy-focused web analytics solution. Analytics data is only sent if you configure the necessary environment variables.

1.  **Create a `.env` file:** Copy the `.env.example` file to a new file named `.env` in the project root:
    ```bash
    cp .env.example .env
    ```
    *(Note: `.env` files are ignored by Git by default via `.gitignore`)*

2.  **Edit `.env`:** Replace the placeholder values in the new `.env` file with your own Umami instance details:
    * `UMAMI_SCRIPT_URL`: The full URL to your Umami `script.js` file (e.g., `https://your-umami-instance.com/script.js`).
    * `UMAMI_WEBSITE_ID`: The unique Website ID provided by your Umami instance for this site.

3.  **Restart Dev Server:** If the development server (`npm run dev`) was already running, stop it (`Ctrl+C`) and restart it to load the new environment variables.

4.  **Deployment:** For analytics to work on your deployed site, you must also configure these same `UMAMI_SCRIPT_URL` and `UMAMI_WEBSITE_ID` environment variables in your hosting provider's settings.


### Usage

1. **Upload an image**: Drag and drop or select a file.
2. **Crop**: Choose presets or custom aspect ratios.
3. **Apply Adjustments & Filters**: Enhance your image to your liking.
4. **Export**: Choose format, quality, and dimensions, then download.

## Technologies Used
- React & Astro for UI components
- Tailwind CSS for styling
- JavaScript Canvas API for image processing

## Privacy First
imgStyler is developed with your privacy in mind—no uploads, and no external dependencies for image processing.

## Contributing
Contributions are welcome! Please submit issues or pull requests to improve functionality or usability.

## License
[MIT License](LICENSE)
---
Developed by [Dev4PGH LLC](https://dev4pgh.com).
</file>

<file path="tsconfig.json">
{
  "extends": "astro/tsconfigs/strict",
  "include": [
    ".astro/types.d.ts",
    "**/*"
  ],
  "exclude": [
    "dist"
  ],
  "compilerOptions": {
    "jsx": "react-jsx",
    "jsxImportSource": "react"
  }
}
</file>

</files>
